using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using KesifUygulamasiTemplate.Services.Interfaces;
using KesifUygulamasiTemplate.Models;

namespace KesifUygulamasiTemplate.Services
{
    /// <summary>
    /// Global routing servisi - CI/CD pipeline ile entegre fallback zinciri
    /// </summary>
    public class RoutingService : IRoutingService
    {
        private readonly ILogger<RoutingService> _logger;
        private readonly IBadgeService _badgeService;
        private readonly IMonitoringService _monitoringService;

        // Provider priority list - CI/CD için environment variable desteği
        private readonly List<string> _providerPriority = new()
        {
            Environment.GetEnvironmentVariable("PRIMARY_ROUTING_PROVIDER") ?? "HERE",
            Environment.GetEnvironmentVariable("SECONDARY_ROUTING_PROVIDER") ?? "Mapbox",
            Environment.GetEnvironmentVariable("TERTIARY_ROUTING_PROVIDER") ?? "Google",
            "Offline"
        };

        // CI/CD için test modu
        private readonly bool _isTestEnvironment = Environment.GetEnvironmentVariable("CI") == "true" ||
                                                  Environment.GetEnvironmentVariable("TEST_ENVIRONMENT") == "true";

        public RoutingService(
            ILogger<RoutingService> logger,
            IBadgeService badgeService,
            IMonitoringService monitoringService)
        {
            _logger = logger;
            _badgeService = badgeService;
            _monitoringService = monitoringService;
        }

        /// <summary>
        /// Global routing fallback zinciri ile rota hesaplar
        /// </summary>
        public async Task<RouteResult> GetRouteAsync(Coordinate from, Coordinate to, RouteOptimizationType optimizationType = RouteOptimizationType.Fastest)
        {
            var providers = new List<IRoutingProvider>
            {
                new HereMapsProvider(_logger),
                new MapboxProvider(_logger),
                new GoogleMapsProvider(_logger),
                new OfflineRoutingProvider(_logger)
            };

            Exception lastException = null;
            RouteResult result = null;

            foreach (var provider in providers)
            {
                try
                {
                    _logger.LogInformation("Routing provider deneniyor: {Provider}", provider.GetType().Name);

                    result = await provider.GetRouteAsync(from, to, optimizationType);

                    if (result != null && result.IsSuccessful)
                    {
                        _logger.LogInformation("✅ Rota başarıyla hesaplandı: {Provider}", provider.GetType().Name);

                        // Monitoring ve badge güncellemeleri
                        await _monitoringService.LogProviderUsageAsync(provider.GetType().Name);
                        await _monitoringService.LogRouteTypeUsageAsync(optimizationType.ToString());

                        // Badge tetikleme
                        await _badgeService.AwardBadgeAsync("Routing-Fallback");

                        return result;
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Routing provider başarısız: {Provider}", provider.GetType().Name);
                    lastException = ex;

                    // Fallback kullanımını logla
                    await _monitoringService.LogFallbackUsageAsync(provider.GetType().Name, ex.Message);
                }
            }

            // Tüm provider'lar başarısız olursa
            _logger.LogError(lastException, "Tüm routing provider'ları başarısız oldu");

            // Test ortamında mock sonuç döndür
            if (_isTestEnvironment)
            {
                _logger.LogInformation("Test ortamı tespit edildi, mock rota sonucu döndürülüyor");
                return await GetMockRouteResultAsync(from, to, optimizationType);
            }

            throw new RoutingException("Tüm routing provider'ları başarısız oldu", lastException);
        }

        /// <summary>
        /// Tüm provider'ların durumunu kontrol eder
        /// </summary>
        public async Task<Dictionary<string, bool>> CheckProviderStatusAsync()
        {
            var status = new Dictionary<string, bool>();
            var providers = new List<IRoutingProvider>
            {
                new HereMapsProvider(_logger),
                new MapboxProvider(_logger),
                new GoogleMapsProvider(_logger),
                new OfflineRoutingProvider(_logger)
            };

            foreach (var provider in providers)
            {
                try
                {
                    var isAvailable = await provider.CheckAvailabilityAsync();
                    status[provider.GetType().Name] = isAvailable;
                    _logger.LogInformation("Provider durumu: {Provider} = {Status}", provider.GetType().Name, isAvailable);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Provider durumu kontrol edilemedi: {Provider}", provider.GetType().Name);
                    status[provider.GetType().Name] = false;
                }
            }

            return status;
        }

        /// <summary>
        /// Test ortamı için mock rota sonucu oluşturur
        /// </summary>
        private async Task<RouteResult> GetMockRouteResultAsync(Coordinate from, Coordinate to, RouteOptimizationType optimizationType)
        {
            // Mock rota hesaplaması
            var distance = CalculateDistance(from, to);
            var duration = TimeSpan.FromMinutes(distance * 2); // Yaklaşık 30km/saat hız

            var mockResult = new RouteResult
            {
                IsSuccessful = true,
                Distance = distance,
                Duration = duration,
                Provider = "MockProvider",
                OptimizationType = optimizationType,
                Steps = new List<RouteStep>
                {
                    new RouteStep
                    {
                        Instruction = "Test rotası başlatıldı",
                        Distance = distance / 2,
                        Duration = TimeSpan.FromMinutes(duration.TotalMinutes / 2)
                    },
                    new RouteStep
                    {
                        Instruction = "Test rotası tamamlandı",
                        Distance = distance / 2,
                        Duration = TimeSpan.FromMinutes(duration.TotalMinutes / 2)
                    }
                }
            };

            _logger.LogInformation("Mock rota sonucu oluşturuldu: {Distance}km, {Duration}", distance, duration);
            return mockResult;
        }

        /// <summary>
        /// İki koordinat arası mesafeyi hesaplar (km cinsinden)
        /// </summary>
        private double CalculateDistance(Coordinate from, Coordinate to)
        {
            const double EarthRadius = 6371; // km

            var dLat = ToRadians(to.Latitude - from.Latitude);
            var dLon = ToRadians(to.Longitude - from.Longitude);

            var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +
                    Math.Cos(ToRadians(from.Latitude)) * Math.Cos(ToRadians(to.Latitude)) *
                    Math.Sin(dLon / 2) * Math.Sin(dLon / 2);

            var c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
            return EarthRadius * c;
        }

        private double ToRadians(double degrees) => degrees * Math.PI / 180;

        // Eski interface metodları için backward compatibility
        public Task<DirectionsRoute?> GetRouteAsync(LatLng from, LatLng to)
        {
            var coordinateFrom = new Coordinate { Latitude = from.Latitude, Longitude = from.Longitude };
            var coordinateTo = new Coordinate { Latitude = to.Latitude, Longitude = to.Longitude };

            return GetRouteAsync(coordinateFrom, coordinateTo).ContinueWith(t =>
            {
                if (t.Result?.IsSuccessful == true)
                {
                    return new DirectionsRoute
                    {
                        Points = new List<LatLng> { from, to },
                        Distance = t.Result.Distance,
                        Duration = t.Result.Duration
                    };
                }
                return null;
            });
        }

        public Task<Route> CalculateRouteAsync(Location start, Location end, TransportMode mode = TransportMode.Driving)
        {
            var coordinateFrom = new Coordinate { Latitude = start.Latitude, Longitude = start.Longitude };
            var coordinateTo = new Coordinate { Latitude = end.Latitude, Longitude = end.Longitude };

            return GetRouteAsync(coordinateFrom, coordinateTo).ContinueWith(t =>
            {
                return new Route
                {
                    Points = new List<Location> { start, end },
                    Distance = t.Result?.Distance ?? 0,
                    Duration = t.Result?.Duration ?? TimeSpan.Zero,
                    Start = start,
                    End = end,
                    Steps = t.Result?.Steps ?? new List<RouteStep>()
                };
            });
        }

        public Task<List<Route>> GetAlternativeRoutesAsync(Location start, Location end, TransportMode mode = TransportMode.Driving)
        {
            return CalculateRouteAsync(start, end, mode).ContinueWith(t =>
                new List<Route> { t.Result });
        }

        public Task<TimeSpan> EstimateTimeAsync(Route route, bool considerTraffic = true)
        {
            return Task.FromResult(route.Duration);
        }
    }

    /// <summary>
    /// Routing provider interface'i
    /// </summary>
    public interface IRoutingProvider
    {
        Task<RouteResult> GetRouteAsync(Coordinate from, Coordinate to, RouteOptimizationType optimizationType);
        Task<bool> CheckAvailabilityAsync();
    }

    /// <summary>
    /// HERE Maps provider
    /// </summary>
    public class HereMapsProvider : IRoutingProvider
    {
        private readonly ILogger _logger;
        private readonly string _apiKey = Environment.GetEnvironmentVariable("HERE_MAPS_API_KEY") ?? "YOUR_HERE_API_KEY";

        public HereMapsProvider(ILogger logger) => _logger = logger;

        public async Task<RouteResult> GetRouteAsync(Coordinate from, Coordinate to, RouteOptimizationType optimizationType)
        {
            // HERE Maps API çağrısı simülasyonu
            _logger.LogInformation("HERE Maps API çağrısı: {From} -> {To}", from, to);
            await Task.Delay(100); // API çağrısı simülasyonu

            if (_apiKey == "YOUR_HERE_API_KEY")
            {
                throw new Exception("HERE Maps API key not configured");
            }

            return new RouteResult
            {
                IsSuccessful = true,
                Distance = 50.5,
                Duration = TimeSpan.FromMinutes(45),
                Provider = "HERE Maps",
                OptimizationType = optimizationType
            };
        }

        public async Task<bool> CheckAvailabilityAsync()
        {
            // API availability kontrolü
            return !string.IsNullOrEmpty(_apiKey) && _apiKey != "YOUR_HERE_API_KEY";
        }
    }

    /// <summary>
    /// Mapbox provider
    /// </summary>
    public class MapboxProvider : IRoutingProvider
    {
        private readonly ILogger _logger;
        private readonly string _apiKey = Environment.GetEnvironmentVariable("MAPBOX_API_KEY") ?? "YOUR_MAPBOX_API_KEY";

        public MapboxProvider(ILogger logger) => _logger = logger;

        public async Task<RouteResult> GetRouteAsync(Coordinate from, Coordinate to, RouteOptimizationType optimizationType)
        {
            _logger.LogInformation("Mapbox API çağrısı: {From} -> {To}", from, to);
            await Task.Delay(100);

            if (_apiKey == "YOUR_MAPBOX_API_KEY")
            {
                throw new Exception("Mapbox API key not configured");
            }

            return new RouteResult
            {
                IsSuccessful = true,
                Distance = 52.1,
                Duration = TimeSpan.FromMinutes(42),
                Provider = "Mapbox",
                OptimizationType = optimizationType
            };
        }

        public async Task<bool> CheckAvailabilityAsync()
        {
            return !string.IsNullOrEmpty(_apiKey) && _apiKey != "YOUR_MAPBOX_API_KEY";
        }
    }

    /// <summary>
    /// Google Maps provider
    /// </summary>
    public class GoogleMapsProvider : IRoutingProvider
    {
        private readonly ILogger _logger;
        private readonly string _apiKey = Environment.GetEnvironmentVariable("GOOGLE_MAPS_API_KEY") ?? "YOUR_GOOGLE_API_KEY";

        public GoogleMapsProvider(ILogger logger) => _logger = logger;

        public async Task<RouteResult> GetRouteAsync(Coordinate from, Coordinate to, RouteOptimizationType optimizationType)
        {
            _logger.LogInformation("Google Maps API çağrısı: {From} -> {To}", from, to);
            await Task.Delay(100);

            if (_apiKey == "YOUR_GOOGLE_API_KEY")
            {
                throw new Exception("Google Maps API key not configured");
            }

            return new RouteResult
            {
                IsSuccessful = true,
                Distance = 48.7,
                Duration = TimeSpan.FromMinutes(38),
                Provider = "Google Maps",
                OptimizationType = optimizationType
            };
        }

        public async Task<bool> CheckAvailabilityAsync()
        {
            return !string.IsNullOrEmpty(_apiKey) && _apiKey != "YOUR_GOOGLE_API_KEY";
        }
    }

    /// <summary>
    /// Offline routing provider
    /// </summary>
    public class OfflineRoutingProvider : IRoutingProvider
    {
        private readonly ILogger _logger;

        public OfflineRoutingProvider(ILogger logger) => _logger = logger;

        public async Task<RouteResult> GetRouteAsync(Coordinate from, Coordinate to, RouteOptimizationType optimizationType)
        {
            _logger.LogInformation("Offline routing hesaplaması: {From} -> {To}", from, to);
            await Task.Delay(50);

            // Basit offline rota hesaplaması
            var distance = Math.Sqrt(Math.Pow(to.Latitude - from.Latitude, 2) + Math.Pow(to.Longitude - from.Longitude, 2)) * 111; // Yaklaşık km

            return new RouteResult
            {
                IsSuccessful = true,
                Distance = distance,
                Duration = TimeSpan.FromMinutes(distance * 3), // Yaklaşık 20km/saat
                Provider = "Offline",
                OptimizationType = optimizationType,
                IsOffline = true
            };
        }

        public async Task<bool> CheckAvailabilityAsync()
        {
            // Offline her zaman kullanılabilir
            return true;
        }
    }

    /// <summary>
    /// Routing exception sınıfı
    /// </summary>
    public class RoutingException : Exception
    {
        public RoutingException(string message, Exception innerException)
            : base(message, innerException) { }
    }
}
