using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace KesifUygulamasiTemplate.Services\n{\n    /// <summary>\n    /// Route deviation detection and fallback routing service\n    /// Monitors route adherence and provides recovery mechanisms\n    /// </summary>\n    public class DeviationHandler\n    {\n        private readonly ILogger<DeviationHandler> _logger;\n        private readonly string _logsPath;\n        private readonly bool _enableDeviationDetection;\n        private readonly double _deviationThresholdMeters;\n        private readonly int _maxRecoveryAttempts;\n        private readonly int _recoveryDelayMs;\n\n        public DeviationHandler(ILogger<DeviationHandler> logger)\n        {\n            _logger = logger;\n            _logsPath = Environment.GetEnvironmentVariable("DEVIATION_LOGS_PATH") ?? "logs/deviations";\n            _enableDeviationDetection = bool.Parse(Environment.GetEnvironmentVariable("ENABLE_DEVIATION_DETECTION") ?? "true");\n            _deviationThresholdMeters = double.Parse(Environment.GetEnvironmentVariable("DEVIATION_THRESHOLD_METERS") ?? "50");\n            _maxRecoveryAttempts = int.Parse(Environment.GetEnvironmentVariable("MAX_RECOVERY_ATTEMPTS") ?? "3");\n            _recoveryDelayMs = int.Parse(Environment.GetEnvironmentVariable("RECOVERY_DELAY_MS") ?? "2000");\n\n            // Logs klasörünü oluştur\n            Directory.CreateDirectory(_logsPath);\n        }\n\n        /// <summary>\n        /// Rota sapmasını kontrol et\n        /// </summary>\n        public async Task<DeviationResult> CheckDeviation(RoutePoint currentLocation, RouteSegment currentSegment)\n        {\n            try\n            {\n                if (!_enableDeviationDetection)\n                {\n                    return new DeviationResult\n                    {\n                        IsDeviated = false,\n                        DeviationDistance = 0,\n                        Message = "Deviation detection is disabled"\n                    };\n                }\n\n                var deviation = CalculateDeviation(currentLocation, currentSegment);\n                var isDeviated = deviation > _deviationThresholdMeters;\n\n                var result = new DeviationResult\n                {\n                    IsDeviated = isDeviated,\n                    DeviationDistance = deviation,\n                    Threshold = _deviationThresholdMeters,\n                    CurrentLocation = currentLocation,\n                    ExpectedSegment = currentSegment,\n                    Timestamp = DateTime.UtcNow\n                };\n\n                if (isDeviated)\n                {\n                    result.Message = $"Route deviation detected: {deviation:F1}m from planned route";\n                    _logger.LogWarning($"Route deviation: {deviation:F1}m at {currentLocation.Latitude:F6}, {currentLocation.Longitude:F6}");\n\n                    // Sapma olayını logla\n                    await LogDeviation(result);\n                }\n                else\n                {\n                    result.Message = $"On route: {deviation:F1}m from planned route";\n                }\n\n                return result;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError($"Deviation check failed: {ex.Message}");\n                return new DeviationResult\n                {\n                    IsDeviated = false,\n                    DeviationDistance = 0,\n                    ErrorMessage = ex.Message\n                };\n            }\n        }\n\n        /// <summary>\n        /// Rota sapması için kurtarma stratejisi uygula\n        /// </summary>\n        public async Task<RecoveryResult> ApplyRecoveryStrategy(DeviationResult deviation, List<RouteSegment> alternativeRoutes)\n        {\n            try\n            {\n                if (!deviation.IsDeviated)\n                {\n                    return new RecoveryResult\n                    {\n                        Success = true,\n                        Strategy = RecoveryStrategy.NoAction,\n                        Message = "No deviation detected, no recovery needed"\n                    };\n                }\n\n                var recoveryStrategies = new List<RecoveryStrategy>\n                {\n                    RecoveryStrategy.RerouteToNearest,\n                    RecoveryStrategy.RecalculateRoute,\n                    RecoveryStrategy.ContinueWithWarning\n                };\n\n                foreach (var strategy in recoveryStrategies)\n                {\n                    var result = await ExecuteRecoveryStrategy(strategy, deviation, alternativeRoutes);\n\n                    if (result.Success)\n                    {\n                        await LogRecovery(result);\n                        return result;\n                    }\n\n                    if (result.AttemptCount >= _maxRecoveryAttempts)\n                    {\n                        break;\n                    }\n\n                    // Kısa bir gecikme ile bir sonraki stratejiyi dene\n                    await Task.Delay(_recoveryDelayMs);\n                }\n\n                // Tüm stratejiler başarısız oldu\n                var failureResult = new RecoveryResult\n                {\n                    Success = false,\n                    Strategy = RecoveryStrategy.Failed,\n                    Message = "All recovery strategies failed",\n                    AttemptCount = recoveryStrategies.Count\n                };\n\n                await LogRecovery(failureResult);\n                return failureResult;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError($"Recovery strategy failed: {ex.Message}");\n                return new RecoveryResult\n                {\n                    Success = false,\n                    Strategy = RecoveryStrategy.Failed,\n                    ErrorMessage = ex.Message\n                };\n            }\n        }\n\n        /// <summary>\n        /// Sapma geçmişini al\n        /// </summary>\n        public async Task<List<DeviationLog>> GetDeviationHistory(string? routeId = null, DateTime? startDate = null, DateTime? endDate = null)\n        {\n            try\n            {\n                var logFiles = Directory.GetFiles(_logsPath, "deviation-*.json")\n                    .Where(f => !startDate.HasValue || File.GetCreationTime(f) >= startDate.Value)\n                    .Where(f => !endDate.HasValue || File.GetCreationTime(f) <= endDate.Value)\n                    .OrderByDescending(f => File.GetCreationTime(f))\n                    .Take(100);\n\n                var history = new List<DeviationLog>();\n\n                foreach (var logFile in logFiles)\n                {\n                    try\n                    {\n                        var content = await File.ReadAllTextAsync(logFile);\n                        var logs = JsonSerializer.Deserialize<List<DeviationLog>>(content);\n\n                        if (logs != null)\n                        {\n                            var filteredLogs = logs.Where(l => routeId == null || l.RouteId == routeId).ToList();\n                            history.AddRange(filteredLogs);\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        _logger.LogWarning($"Failed to read deviation log {logFile}: {ex.Message}");\n                    }\n                }\n\n                return history.OrderByDescending(l => l.Timestamp).Take(1000).ToList();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError($"Failed to get deviation history: {ex.Message}");\n                return new List<DeviationLog>();\n            }\n        }\n\n        /// <summary>\n        /// Kurtarma geçmişini al\n        /// </summary>\n        public async Task<List<RecoveryLog>> GetRecoveryHistory(string? routeId = null, DateTime? startDate = null, DateTime? endDate = null)\n        {\n            try\n            {\n                var logFiles = Directory.GetFiles(_logsPath, "recovery-*.json")\n                    .Where(f => !startDate.HasValue || File.GetCreationTime(f) >= startDate.Value)\n                    .Where(f => !endDate.HasValue || File.GetCreationTime(f) <= endDate.Value)\n                    .OrderByDescending(f => File.GetCreationTime(f))\n                    .Take(100);\n\n                var history = new List<RecoveryLog>();\n\n                foreach (var logFile in logFiles)\n                {\n                    try\n                    {\n                        var content = await File.ReadAllTextAsync(logFile);\n                        var logs = JsonSerializer.Deserialize<List<RecoveryLog>>(content);\n\n                        if (logs != null)\n                        {\n                            var filteredLogs = logs.Where(l => routeId == null || l.RouteId == routeId).ToList();\n                            history.AddRange(filteredLogs);\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        _logger.LogWarning($"Failed to read recovery log {logFile}: {ex.Message}");\n                    }\n                }\n\n                return history.OrderByDescending(l => l.Timestamp).Take(1000).ToList();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError($"Failed to get recovery history: {ex.Message}");\n                return new List<RecoveryLog>();\n            }\n        }\n\n        /// <summary>\n        /// Sapma istatistiklerini al\n        /// </summary>\n        public async Task<DeviationStats> GetDeviationStats(DateTime? startDate = null, DateTime? endDate = null)\n        {\n            var deviationHistory = await GetDeviationHistory(null, startDate, endDate);\n            var recoveryHistory = await GetRecoveryHistory(null, startDate, endDate);\n\n            return new DeviationStats\n            {\n                TotalDeviations = deviationHistory.Count,\n                SuccessfulRecoveries = recoveryHistory.Count(l => l.Success),\n                FailedRecoveries = recoveryHistory.Count(l => !l.Success),\n                AverageDeviationDistance = deviationHistory.Count > 0 ? deviationHistory.Average(d => d.DeviationDistance) : 0,\n                MaxDeviationDistance = deviationHistory.Count > 0 ? deviationHistory.Max(d => d.DeviationDistance) : 0,\n                RecoveryRate = recoveryHistory.Count > 0 ? (double)recoveryHistory.Count(l => l.Success) / recoveryHistory.Count * 100 : 0,\n                PeriodStart = startDate ?? deviationHistory.Min(l => l.Timestamp),\n                PeriodEnd = endDate ?? deviationHistory.Max(l => l.Timestamp)\n            };\n        }\n\n        /// <summary>\n        /// Sapma mesafesini hesapla\n        /// </summary>\n        private double CalculateDeviation(RoutePoint currentLocation, RouteSegment segment)\n        {\n            // Haversine formülü ile iki nokta arası mesafe\n            var dLat = ToRadians(currentLocation.Latitude - segment.StartPoint.Latitude);\n            var dLon = ToRadians(currentLocation.Longitude - segment.StartPoint.Longitude);\n\n            var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +\n                    Math.Cos(ToRadians(segment.StartPoint.Latitude)) * Math.Cos(ToRadians(currentLocation.Latitude)) *\n                    Math.Sin(dLon / 2) * Math.Sin(dLon / 2);\n\n            var c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));\n\n            // Dünya yarıçapı (metre cinsinden)\n            const double EarthRadius = 6371000;\n            return EarthRadius * c;\n        }\n\n        /// <summary>\n        /// Dereceyi radyana çevir\n        /// </summary>\n        private double ToRadians(double degrees)\n        {\n            return degrees * Math.PI / 180.0;\n        }\n\n        /// <summary>\n        /// Kurtarma stratejisini çalıştır\n        /// </summary>\n        private async Task<RecoveryResult> ExecuteRecoveryStrategy(RecoveryStrategy strategy, DeviationResult deviation, List<RouteSegment> alternativeRoutes)\n        {\n            var result = new RecoveryResult\n            {\n                Strategy = strategy,\n                AttemptCount = 1,\n                Timestamp = DateTime.UtcNow\n            };\n\n            try\n            {\n                switch (strategy)\n                {\n                    case RecoveryStrategy.RerouteToNearest:\n                        result = await ExecuteRerouteToNearest(deviation, alternativeRoutes);\n                        break;\n                    case RecoveryStrategy.RecalculateRoute:\n                        result = await ExecuteRecalculateRoute(deviation);\n                        break;\n                    case RecoveryStrategy.ContinueWithWarning:\n                        result = await ExecuteContinueWithWarning(deviation);\n                        break;\n                }\n            }\n            catch (Exception ex)\n            {\n                result.Success = false;\n                result.ErrorMessage = ex.Message;\n            }\n\n            return result;\n        }\n\n        /// <summary>\n        /// En yakın rotaya yönlendirme stratejisi\n        /// </summary>\n        private async Task<RecoveryResult> ExecuteRerouteToNearest(DeviationResult deviation, List<RouteSegment> alternativeRoutes)\n        {\n            await Task.Delay(500); // Simüle edilmiş işlem süresi\n\n            if (alternativeRoutes.Count == 0)\n            {\n                return new RecoveryResult\n                {\n                    Success = false,\n                    Strategy = RecoveryStrategy.RerouteToNearest,\n                    Message = "No alternative routes available"\n                };\n            }\n\n            // En yakın alternatifi bul (basit implementasyon)\n            var nearestRoute = alternativeRoutes.OrderBy(r =>\n                CalculateDeviation(deviation.CurrentLocation, r)).First();\n\n            return new RecoveryResult\n            {\n                Success = true,\n                Strategy = RecoveryStrategy.RerouteToNearest,\n                Message = "Rerouted to nearest alternative route",\n                NewRoute = nearestRoute\n            };\n        }\n\n        /// <summary>\n        /// Rota yeniden hesaplama stratejisi\n        /// </summary>\n        private async Task<RecoveryResult> ExecuteRecalculateRoute(DeviationResult deviation)\n        {\n            await Task.Delay(1000); // Simüle edilmiş API çağrısı\n\n            // Rota yeniden hesaplama simülasyonu\n            var success = new Random().NextDouble() > 0.2; // %80 başarı oranı\n\n            return new RecoveryResult\n            {\n                Success = success,\n                Strategy = RecoveryStrategy.RecalculateRoute,\n                Message = success ? "Route recalculated successfully" : "Route recalculation failed",\n                NewRoute = success ? new RouteSegment\n                {\n                    StartPoint = deviation.CurrentLocation,\n                    EndPoint = deviation.ExpectedSegment.EndPoint\n                } : null\n            };\n        }\n\n        /// <summary>\n        /// Uyarı ile devam etme stratejisi\n        /// </summary>\n        private async Task<RecoveryResult> ExecuteContinueWithWarning(DeviationResult deviation)\n        {\n            await Task.Delay(200); // Simüle edilmiş işlem süresi\n\n            return new RecoveryResult\n            {\n                Success = true,\n                Strategy = RecoveryStrategy.ContinueWithWarning,\n                Message = "Continuing with route deviation warning",\n                WarningIssued = true\n            };\n        }\n\n        /// <summary>\n        /// Sapmayı logla\n        /// </summary>\n        private async Task LogDeviation(DeviationResult deviation)\n        {\n            try\n            {\n                var logEntry = new DeviationLog\n                {\n                    Id = Guid.NewGuid().ToString(),\n                    RouteId = deviation.ExpectedSegment?.RouteId,\n                    DeviationDistance = deviation.DeviationDistance,\n                    Threshold = deviation.Threshold,\n                    CurrentLocation = deviation.CurrentLocation,\n                    ExpectedSegment = deviation.ExpectedSegment,\n                    Timestamp = deviation.Timestamp,\n                    Message = deviation.Message\n                };\n\n                var logFile = Path.Combine(_logsPath, $"deviation-{DateTime.UtcNow:yyyy-MM-dd}.json");\n\n                List<DeviationLog> existingLogs = new List<DeviationLog>();\n\n                if (File.Exists(logFile))\n                {\n                    try\n                    {\n                        var content = await File.ReadAllTextAsync(logFile);\n                        existingLogs = JsonSerializer.Deserialize<List<DeviationLog>>(content) ?? new List<DeviationLog>();\n                    }\n                    catch\n                    {\n                        // Log dosyası bozuk ise yeni liste oluştur\n                    }\n                }\n\n                existingLogs.Add(logEntry);\n\n                var json = JsonSerializer.Serialize(existingLogs, new JsonSerializerOptions\n                {\n                    WriteIndented = true,\n                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase\n                });\n\n                await File.WriteAllTextAsync(logFile, json);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError($"Failed to log deviation: {ex.Message}");\n            }\n        }\n\n        /// <summary>\n        /// Kurtarmayı logla\n        /// </summary>\n        private async Task LogRecovery(RecoveryResult recovery)\n        {\n            try\n            {\n                var logEntry = new RecoveryLog\n                {\n                    Id = Guid.NewGuid().ToString(),\n                    RouteId = recovery.NewRoute?.RouteId,\n                    Strategy = recovery.Strategy,\n                    Success = recovery.Success,\n                    AttemptCount = recovery.AttemptCount,\n                    Timestamp = recovery.Timestamp,\n                    Message = recovery.Message,\n                    ErrorMessage = recovery.ErrorMessage\n                };\n\n                var logFile = Path.Combine(_logsPath, $"recovery-{DateTime.UtcNow:yyyy-MM-dd}.json");\n\n                List<RecoveryLog> existingLogs = new List<RecoveryLog>();\n\n                if (File.Exists(logFile))\n                {\n                    try\n                    {\n                        var content = await File.ReadAllTextAsync(logFile);\n                        existingLogs = JsonSerializer.Deserialize<List<RecoveryLog>>(content) ?? new List<RecoveryLog>();\n                    }\n                    catch\n                    {\n                        // Log dosyası bozuk ise yeni liste oluştur\n                    }\n                }\n\n                existingLogs.Add(logEntry);\n\n                var json = JsonSerializer.Serialize(existingLogs, new JsonSerializerOptions\n                {\n                    WriteIndented = true,\n                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase\n                });\n\n                await File.WriteAllTextAsync(logFile, json);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError($"Failed to log recovery: {ex.Message}");\n            }\n        }\n    }\n\n    public class RoutePoint\n    {\n        public double Latitude { get; set; }\n        public double Longitude { get; set; }\n        public double? Altitude { get; set; }\n        public DateTime? Timestamp { get; set; }\n    }\n\n    public class RouteSegment\n    {\n        public string? RouteId { get; set; }\n        public RoutePoint StartPoint { get; set; } = new RoutePoint();\n        public RoutePoint EndPoint { get; set; } = new RoutePoint();\n        public double Distance { get; set; }\n        public TimeSpan? EstimatedDuration { get; set; }\n    }\n\n    public class DeviationResult\n    {\n        public bool IsDeviated { get; set; }\n        public double DeviationDistance { get; set; }\n        public double Threshold { get; set; }\n        public RoutePoint? CurrentLocation { get; set; }\n        public RouteSegment? ExpectedSegment { get; set; }\n        public DateTime Timestamp { get; set; }\n        public string? Message { get; set; }\n        public string? ErrorMessage { get; set; }\n    }\n\n    public class RecoveryResult\n    {\n        public bool Success { get; set; }\n        public RecoveryStrategy Strategy { get; set; }\n        public int AttemptCount { get; set; }\n        public RouteSegment? NewRoute { get; set; }\n        public DateTime Timestamp { get; set; }\n        public string? Message { get; set; }\n        public string? ErrorMessage { get; set; }\n        public bool WarningIssued { get; set; }\n    }\n\n    public class DeviationStats\n    {\n        public int TotalDeviations { get; set; }\n        public int SuccessfulRecoveries { get; set; }\n        public int FailedRecoveries { get; set; }\n        public double AverageDeviationDistance { get; set; }\n        public double MaxDeviationDistance { get; set; }\n        public double RecoveryRate { get; set; }\n        public DateTime PeriodStart { get; set; }\n        public DateTime PeriodEnd { get; set; }\n    }\n\n    public class DeviationLog\n    {\n        public string? Id { get; set; }\n        public string? RouteId { get; set; }\n        public double DeviationDistance { get; set; }\n        public double Threshold { get; set; }\n        public RoutePoint? CurrentLocation { get; set; }\n        public RouteSegment? ExpectedSegment { get; set; }\n        public DateTime Timestamp { get; set; }\n        public string? Message { get; set; }\n    }\n\n    public class RecoveryLog\n    {\n        public string? Id { get; set; }\n        public string? RouteId { get; set; }\n        public RecoveryStrategy Strategy { get; set; }\n        public bool Success { get; set; }\n        public int AttemptCount { get; set; }\n        public DateTime Timestamp { get; set; }\n        public string? Message { get; set; }\n        public string? ErrorMessage { get; set; }\n    }\n\n    public enum RecoveryStrategy\n    {\n        NoAction,\n        RerouteToNearest,\n        RecalculateRoute,\n        ContinueWithWarning,\n        Failed\n    }\n}\n