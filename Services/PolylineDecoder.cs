using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing KesifUygulamasiTemplate.Models;\n\nnamespace KesifUygulamasiTemplate.Services\n{\n    /// <summary>\n    /// HERE Maps Flexible Polyline encoding/decoding algoritması\n    /// https://github.com/heremaps/flexible-polyline\n    /// </summary>\n    public static class PolylineDecoder\n    {\n        private const int COORDINATE_PRECISION = 5; // 5 decimal places\n        private const int THIRD_DIM_PRECISION = 2;  // 2 decimal places for elevation/time\n        private const string ENCODING_TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";\n\n        /// <summary>\n        /// HERE Flexible Polyline string'ini koordinat listesine çevirir\n        /// </summary>\n        /// <param name="encoded">Encoded polyline string</param>\n        /// <returns>List of LatLng coordinates</returns>\n        public static List<LatLng> Decode(string encoded)\n        {\n            if (string.IsNullOrEmpty(encoded))\n                return new List<LatLng>();\n\n            try\n            {\n                var decoder = new FlexiblePolylineDecoder(encoded);\n                var tuples = decoder.Decode();\n                return tuples.Select(t => new LatLng(t.lat, t.lon)).ToList();\n            }\n            catch (Exception)\n            {\n                // Decode hatası durumunda boş liste döndür\n                return new List<LatLng>();\n            }\n        }\n\n        /// <summary>\n        /// Koordinat listesini HERE Flexible Polyline string'ine çevirir\n        /// </summary>\n        /// <param name="coordinates">List of LatLng coordinates</param>\n        /// <returns>Encoded polyline string</returns>\n        public static string Encode(List<LatLng> coordinates)\n        {\n            if (coordinates == null || coordinates.Count == 0)\n                return string.Empty;\n\n            try\n            {\n                var tuples = coordinates.Select(c => (lat: c.Lat, lon: c.Lng)).ToList();\n                var encoder = new FlexiblePolylineEncoder(tuples);\n                return encoder.Encode();\n            }\n            catch (Exception)\n            {\n                return string.Empty;\n            }\n        }\n\n        /// <summary>\n        /// Flexible Polyline Decoder implementasyonu\n        /// </summary>\n        private class FlexiblePolylineDecoder\n        {\n            private readonly string _encoded;\n            private int _index;\n            private int _precision;\n\n            public FlexiblePolylineDecoder(string encoded)\n            {\n                _encoded = encoded;\n                _index = 0;\n                _precision = COORDINATE_PRECISION;\n            }\n\n            public List<(double lat, double lon)> Decode()\n            {\n                var coordinates = new List<(double, double)>();\n\n                // Header decode\n                var header = DecodeUnsignedVarint();\n                var version = (int)(header >> 3);\n                var hasThirdDimension = (header & 0x04) != 0;\n\n                if (version != 1)\n                    throw new InvalidOperationException("Unsupported polyline version");\n\n                // Precision decode\n                _precision = (int)DecodeUnsignedVarint();\n\n                // Third dimension precision (eğer varsa)\n                if (hasThirdDimension)\n                    DecodeUnsignedVarint(); // Skip third dimension precision\n\n                // Coordinates decode\n                double lat = 0, lon = 0;\n                while (_index < _encoded.Length)\n                {\n                    lat += DecodeSignedVarint() * Math.Pow(10, -_precision);\n                    lon += DecodeSignedVarint() * Math.Pow(10, -_precision);\n\n                    coordinates.Add((lat, lon));\n\n                    // Third dimension skip (eğer varsa)\n                    if (hasThirdDimension)\n                        DecodeSignedVarint();\n                }\n\n                return coordinates;\n            }\n\n            private long DecodeUnsignedVarint()\n            {\n                long value = 0;\n                int shift = 0;\n                int b;\n\n                do\n                {\n                    if (_index >= _encoded.Length)\n                        throw new InvalidOperationException("Unexpected end of polyline");\n\n                    b = ENCODING_TABLE.IndexOf(_encoded[_index++]);\n                    if (b < 0)\n                        throw new InvalidOperationException("Invalid character in polyline");\n\n                    value |= (long)(b & 0x1F) << shift;\n                    shift += 5;\n                } while ((b & 0x20) != 0);\n\n                return value;\n            }\n\n            private long DecodeSignedVarint()\n            {\n                var unsigned = DecodeUnsignedVarint();\n                return (unsigned & 1) != 0 ? ~(unsigned >> 1) : (unsigned >> 1);\n            }\n        }\n\n        /// <summary>\n        /// Flexible Polyline Encoder implementasyonu\n        /// </summary>\n        private class FlexiblePolylineEncoder\n        {\n            private readonly List<(double lat, double lon)> _coordinates;\n            private readonly int _precision;\n\n            public FlexiblePolylineEncoder(List<(double lat, double lon)> coordinates)\n            {\n                _coordinates = coordinates;\n                _precision = COORDINATE_PRECISION;\n            }\n\n            public string Encode()\n            {\n                var result = new System.Text.StringBuilder();\n\n                // Header encode (version 1, no third dimension)\n                EncodeUnsignedVarint(result, (1 << 3) | 0);\n\n                // Precision encode\n                EncodeUnsignedVarint(result, _precision);\n\n                // Coordinates encode\n                double prevLat = 0, prevLon = 0;\n                foreach (var (lat, lon) in _coordinates)\n                {\n                    var deltaLat = (long)Math.Round((lat - prevLat) * Math.Pow(10, _precision));\n                    var deltaLon = (long)Math.Round((lon - prevLon) * Math.Pow(10, _precision));\n\n                    EncodeSignedVarint(result, deltaLat);\n                    EncodeSignedVarint(result, deltaLon);\n\n                    prevLat = lat;\n                    prevLon = lon;\n                }\n\n                return result.ToString();\n            }\n\n            private void EncodeUnsignedVarint(System.Text.StringBuilder result, long value)\n            {\n                while (value > 0x1F)\n                {\n                    result.Append(ENCODING_TABLE[(int)((value & 0x1F) | 0x20)]);\n                    value >>= 5;\n                }\n                result.Append(ENCODING_TABLE[(int)value]);\n            }\n\n            private void EncodeSignedVarint(System.Text.StringBuilder result, long value)\n            {\n                var unsigned = value < 0 ? ~(value << 1) : (value << 1);\n                EncodeUnsignedVarint(result, unsigned);\n            }\n        }\n    }\n}\n