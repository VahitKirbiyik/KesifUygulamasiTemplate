using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace KesifUygulamasiTemplate.Services\n{\n    /// <summary>\n    /// Tile prefetch management servisi\n    /// Harita tile'larƒ±nƒ± √∂nceden indirme ve cache y√∂netimi\n    /// </summary>\n    public class PrefetchManager\n    {\n        private readonly ILogger<PrefetchManager> _logger;\n        private readonly TileCompressor _tileCompressor;\n        private readonly string _cachePath;\n        private readonly int _maxConcurrentDownloads;\n        private readonly int _prefetchRadius;\n        private readonly bool _enablePrefetch;\n        private readonly TimeSpan _cacheExpiration;\n\n        public PrefetchManager(ILogger<PrefetchManager> logger, TileCompressor tileCompressor)\n        {\n            _logger = logger;\n            _tileCompressor = tileCompressor;\n            _cachePath = Environment.GetEnvironmentVariable("TILE_CACHE_PATH") ?? "cache/tiles";\n            _maxConcurrentDownloads = int.Parse(Environment.GetEnvironmentVariable("MAX_CONCURRENT_DOWNLOADS") ?? "5");\n            _prefetchRadius = int.Parse(Environment.GetEnvironmentVariable("PREFETCH_RADIUS") ?? "2");\n            _enablePrefetch = bool.Parse(Environment.GetEnvironmentVariable("ENABLE_PREFETCH") ?? "true");\n            _cacheExpiration = TimeSpan.FromHours(int.Parse(Environment.GetEnvironmentVariable("CACHE_EXPIRATION_HOURS") ?? "24"));\n        }\n\n        /// <summary>\n        /// Rota i√ßin tile'larƒ± prefetch et\n        /// </summary>\n        public async Task PrefetchTiles(Coordinate[] route)\n        {\n            if (!_enablePrefetch || route == null || route.Length == 0)\n            {\n                _logger.LogInformation("Prefetch disabled or no route provided");\n                return;\n            }\n\n            try\n            {\n                _logger.LogInformation($"Starting prefetch for {route.Length} route points");\n\n                // Rota √ºzerindeki tile'larƒ± hesapla\n                var routeTiles = CalculateRouteTiles(route);\n\n                // √ñncelik sƒ±rasƒ±na g√∂re tile'larƒ± prefetch et\n                var prioritizedTiles = PrioritizeTiles(routeTiles, route);\n\n                // Paralel indirme ile tile'larƒ± prefetch et\n                await DownloadTilesInParallel(prioritizedTiles);\n\n                _logger.LogInformation($"Prefetch completed for {prioritizedTiles.Count} tiles");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError($"Prefetch failed: {ex.Message}");\n            }\n        }\n\n        /// <summary>\n        /// Belirli bir b√∂lge i√ßin tile'larƒ± prefetch et\n        /// </summary>\n        public async Task PrefetchRegion(double centerLat, double centerLng, int zoom, int radius = 2)\n        {\n            if (!_enablePrefetch)\n            {\n                _logger.LogInformation("Prefetch disabled");\n                return;\n            }\n\n            try\n            {\n                _logger.LogInformation($"Starting region prefetch: {centerLat}, {centerLng}, zoom: {zoom}, radius: {radius}");\n\n                // B√∂lge i√ßindeki tile'larƒ± hesapla\n                var regionTiles = CalculateRegionTiles(centerLat, centerLng, zoom, radius);\n\n                // Tile'larƒ± prefetch et\n                await DownloadTilesInParallel(regionTiles);\n\n                _logger.LogInformation($"Region prefetch completed for {regionTiles.Count} tiles");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError($"Region prefetch failed: {ex.Message}");\n            }\n        }\n\n        /// <summary>\n        /// Kullanƒ±cƒ± hareketine g√∂re predictive prefetch\n        /// </summary>\n        public async Task PredictivePrefetch(Coordinate currentPosition, Coordinate velocity, int zoom)\n        {\n            if (!_enablePrefetch)\n            {\n                return;\n            }\n\n            try\n            {\n                // Kullanƒ±cƒ±nƒ±n hareket y√∂n√ºne g√∂re gelecekteki pozisyonlarƒ± tahmin et\n                var predictedPositions = PredictFuturePositions(currentPosition, velocity);\n\n                // Tahmin edilen pozisyonlar i√ßin tile'larƒ± prefetch et\n                await PrefetchTiles(predictedPositions.ToArray());\n\n                _logger.LogInformation($"Predictive prefetch completed for {predictedPositions.Count} predicted positions");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError($"Predictive prefetch failed: {ex.Message}");\n            }\n        }\n\n        /// <summary>\n        /// Cache'deki tile'larƒ± temizle\n        /// </summary>\n        public async Task<int> CleanupExpiredTiles()\n        {\n            try\n            {\n                var expiredTiles = 0;\n                var cacheFiles = System.IO.Directory.GetFiles(_cachePath, "*.tile", System.IO.SearchOption.AllDirectories);\n\n                foreach (var file in cacheFiles)\n                {\n                    var fileInfo = new System.IO.FileInfo(file);\n                    if (DateTime.UtcNow - fileInfo.LastAccessTimeUtc > _cacheExpiration)\n                    {\n                        System.IO.File.Delete(file);\n                        expiredTiles++;\n                    }\n                }\n\n                _logger.LogInformation($"Cleaned up {expiredTiles} expired tiles");\n                return expiredTiles;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError($"Failed to cleanup expired tiles: {ex.Message}");\n                return 0;\n            }\n        }\n\n        /// <summary>\n        /// Cache istatistiklerini getir\n        /// </summary>\n        public async Task<PrefetchStats> GetCacheStats()\n        {\n            try\n            {\n                var stats = new PrefetchStats();\n                var cacheFiles = System.IO.Directory.GetFiles(_cachePath, "*.tile", System.IO.SearchOption.AllDirectories);\n\n                stats.TotalTiles = cacheFiles.Length;\n                stats.TotalSize = cacheFiles.Sum(f => new System.IO.FileInfo(f).Length);\n                stats.CacheHitRate = CalculateCacheHitRate();\n\n                // En son eri≈üilen tile'larƒ± bul\n                var recentFiles = cacheFiles\n                    .Select(f => new System.IO.FileInfo(f))\n                    .OrderByDescending(f => f.LastAccessTimeUtc)\n                    .Take(10);\n\n                stats.RecentTiles = recentFiles.Select(f => f.Name).ToList();\n\n                return stats;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError($"Failed to get cache stats: {ex.Message}");\n                return new PrefetchStats();\n            }\n        }\n\n        /// <summary>\n        /// Tile indirme √∂nceliƒüini belirle\n        /// </summary>\n        private List<TileInfo> PrioritizeTiles(List<TileInfo> tiles, Coordinate[] route)\n        {\n            // Rota √ºzerindeki tile'lara daha y√ºksek √∂ncelik ver\n            var routeTileSet = new HashSet<string>(route.SelectMany(p => GetTilesForCoordinate(p.Lat, p.Lng, 15))); // Varsayƒ±lan zoom\n\n            return tiles.OrderByDescending(t =>\n            {\n                var priority = 1;\n\n                // Rota √ºzerindeki tile'lara bonus\n                if (routeTileSet.Contains(t.Key))\n                    priority += 10;\n\n                // Yakƒ±nlƒ±ƒüa g√∂re √∂ncelik (daha yakƒ±n tile'lar √∂nce)\n                // Bu kƒ±sƒ±m basitle≈ütirilmi≈ü - ger√ßek implementasyonda daha sofistike olabilir\n\n                return priority;\n            }).ToList();\n        }\n\n        /// <summary>\n        /// Tile'larƒ± paralel olarak indir\n        /// </summary>\n        private async Task DownloadTilesInParallel(List<TileInfo> tiles)\n        {\n            var semaphore = new System.Threading.SemaphoreSlim(_maxConcurrentDownloads);\n            var tasks = new List<Task>();\n\n            foreach (var tile in tiles)\n            {\n                tasks.Add(Task.Run(async () =>\n                {\n                    await semaphore.WaitAsync();\n                    try\n                    {\n                        await DownloadTile(tile);\n                    }\n                    finally\n                    {\n                        semaphore.Release();\n                    }\n                }));\n            }\n\n            await Task.WhenAll(tasks);\n        }\n\n        /// <summary>\n        /// Tek bir tile'ƒ± indir\n        /// </summary>\n        private async Task DownloadTile(TileInfo tile)\n        {\n            try\n            {\n                // Bu kƒ±sƒ±m ger√ßek harita saƒülayƒ±cƒ±sƒ± entegrasyonuna g√∂re deƒüi≈üir\n                // ≈ûimdilik mock implementasyon\n                _logger.LogInformation($"üì¶ Prefetching tile for: {tile.Lat}, {tile.Lng}");\n\n                // Sim√ºle edilmi≈ü tile verisi\n                var tileData = GenerateMockTileData();\n\n                // Tile'ƒ± sƒ±kƒ±≈ütƒ±r ve kaydet\n                var success = await _tileCompressor.SaveCompressedTile(tile.Key, tileData);\n\n                if (success)\n                {\n                    _logger.LogInformation($"‚úÖ Tile prefetched: {tile.Key}");\n                }\n                else\n                {\n                    _logger.LogWarning($"‚ùå Failed to prefetch tile: {tile.Key}");\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError($"Failed to download tile {tile.Key}: {ex.Message}");\n            }\n        }\n\n        /// <summary>\n        /// Rota √ºzerindeki tile'larƒ± hesapla\n        /// </summary>\n        private List<TileInfo> CalculateRouteTiles(Coordinate[] route)\n        {\n            var tiles = new HashSet<TileInfo>();\n            var zoomLevels = new[] { 10, 12, 15 }; // Farklƒ± zoom seviyeleri i√ßin\n\n            foreach (var point in route)\n            {\n                foreach (var zoom in zoomLevels)\n                {\n                    var tileKeys = GetTilesForCoordinate(point.Lat, point.Lng, zoom);\n                    foreach (var key in tileKeys)\n                    {\n                        tiles.Add(new TileInfo\n                        {\n                            Key = key,\n                            Lat = point.Lat,\n                            Lng = point.Lng,\n                            Zoom = zoom\n                        });\n                    }\n                }\n            }\n\n            return tiles.ToList();\n        }\n\n        /// <summary>\n        /// B√∂lge i√ßindeki tile'larƒ± hesapla\n        /// </summary>\n        private List<TileInfo> CalculateRegionTiles(double centerLat, double centerLng, int zoom, int radius)\n        {\n            var tiles = new List<TileInfo>();\n            var centerTile = LatLngToTile(centerLat, centerLng, zoom);\n\n            // Merkez tile'ƒ±n etrafƒ±ndaki tile'larƒ± hesapla\n            for (int x = centerTile.X - radius; x <= centerTile.X + radius; x++)\n            {\n                for (int y = centerTile.Y - radius; y <= centerTile.Y + radius; y++)\n                {\n                    var tileLatLng = TileToLatLng(x, y, zoom);\n                    tiles.Add(new TileInfo\n                    {\n                        Key = $"{zoom}/{x}/{y}",\n                        Lat = tileLatLng.Lat,\n                        Lng = tileLatLng.Lng,\n                        Zoom = zoom\n                    });\n                }\n            }\n\n            return tiles;\n        }\n\n        /// <summary>\n        /// Gelecekteki pozisyonlarƒ± tahmin et\n        /// </summary>\n        private List<Coordinate> PredictFuturePositions(Coordinate current, Coordinate velocity)\n        {\n            var predictions = new List<Coordinate>();\n            var timeSteps = 5; // 5 adƒ±m ileriye tahmin\n            var timeInterval = 10; // 10 saniye aralƒ±klar\n\n            for (int i = 1; i <= timeSteps; i++)\n            {\n                var time = i * timeInterval;\n                var predictedLat = current.Lat + (velocity.Lat * time / 3600); // Saat ba≈üƒ±na d√∂n√º≈ü√ºm\n                var predictedLng = current.Lng + (velocity.Lng * time / 3600);\n\n                predictions.Add(new Coordinate { Lat = predictedLat, Lng = predictedLng });\n            }\n\n            return predictions;\n        }\n\n        /// <summary>\n        /// Koordinat i√ßin tile anahtarlarƒ±nƒ± getir\n        /// </summary>\n        private List<string> GetTilesForCoordinate(double lat, double lng, int zoom)\n        {\n            var tile = LatLngToTile(lat, lng, zoom);\n            var tiles = new List<string>();\n\n            // Ana tile\n            tiles.Add($"{zoom}/{tile.X}/{tile.Y}");\n\n            // √áevre tile'lar (prefetch radius'a g√∂re)\n            for (int dx = -_prefetchRadius; dx <= _prefetchRadius; dx++)\n            {\n                for (int dy = -_prefetchRadius; dy <= _prefetchRadius; dy++)\n                {\n                    if (dx == 0 && dy == 0) continue; // Ana tile zaten eklendi\n\n                    var neighborX = tile.X + dx;\n                    var neighborY = tile.Y + dy;\n\n                    tiles.Add($"{zoom}/{neighborX}/{neighborY}");\n                }\n            }\n\n            return tiles;\n        }\n\n        /// <summary>\n        /// Cache hit rate hesapla\n        /// </summary>\n        private double CalculateCacheHitRate()\n        {\n            // Bu kƒ±sƒ±m ger√ßek implementasyonda daha sofistike olabilir\n            // ≈ûimdilik basit bir oran d√∂nd√ºr√ºl√ºyor\n            return 0.85; // %85 cache hit rate\n        }\n\n        /// <summary>\n        /// Mock tile verisi olu≈ütur\n        /// </summary>\n        private byte[] GenerateMockTileData()\n        {\n            // 256x256 PNG tile sim√ºlasyonu\n            var random = new Random();\n            var data = new byte[1024]; // Basitle≈ütirilmi≈ü\n            random.NextBytes(data);\n            return data;\n        }\n\n        /// <summary>\n        /// LatLng'den Tile koordinatƒ±na d√∂n√º≈ü√ºm\n        /// </summary>\n        private (int X, int Y) LatLngToTile(double lat, double lng, int zoom)\n        {\n            var x = (int)Math.Floor((lng + 180.0) / 360.0 * Math.Pow(2.0, zoom));\n            var y = (int)Math.Floor((1.0 - Math.Log(Math.Tan(lat * Math.PI / 180.0) + 1.0 / Math.Cos(lat * Math.PI / 180.0)) / Math.PI) / 2.0 * Math.Pow(2.0, zoom));\n            return (x, y);\n        }\n\n        /// <summary>\n        /// Tile koordinatƒ±ndan LatLng'ye d√∂n√º≈ü√ºm\n        /// </summary>\n        private (double Lat, double Lng) TileToLatLng(int x, int y, int zoom)\n        {\n            var n = Math.PI - 2.0 * Math.PI * y / Math.Pow(2.0, zoom);\n            var lat = 180.0 / Math.PI * Math.Atan(0.5 * (Math.Exp(n) - Math.Exp(-n)));\n            var lng = x / Math.Pow(2.0, zoom) * 360.0 - 180.0;\n            return (lat, lng);\n        }\n    }\n\n    public class Coordinate\n    {\n        public double Lat { get; set; }\n        public double Lng { get; set; }\n    }\n\n    public class TileInfo\n    {\n        public string Key { get; set; }\n        public double Lat { get; set; }\n        public double Lng { get; set; }\n        public int Zoom { get; set; }\n    }\n\n    public class PrefetchStats\n    {\n        public int TotalTiles { get; set; }\n        public long TotalSize { get; set; }\n        public double CacheHitRate { get; set; }\n        public List<string> RecentTiles { get; set; } = new List<string>();\n\n        public string GetTotalSizeString()\n        {\n            return $"{TotalSize / 1024 / 1024:F2} MB";\n        }\n\n        public string GetCacheHitRateString()\n        {\n            return $"{CacheHitRate:P2}";\n        }\n    }\n}\n