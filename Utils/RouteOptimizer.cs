using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing KesifUygulamasiTemplate.Models;\nusing KesifUygulamasiTemplate.Services;\nusing KesifUygulamasiTemplate.Services.Interfaces;\n\nnamespace KesifUygulamasiTemplate.Utils\n{\n    /// <summary>\n    /// Rota üzerindeki durakları optimize eden servis\n    /// Traveling Salesman Problem (TSP) benzeri algoritmalar kullanır\n    /// </summary>\n    public class RouteOptimizer\n    {\n        private readonly ITrafficDataProvider? _trafficProvider;\n        private readonly IRouteService _routeService;\n\n        public RouteOptimizer(IRouteService routeService, ITrafficDataProvider? trafficProvider = null)\n        {\n            _routeService = routeService ?? throw new ArgumentNullException(nameof(routeService));\n            _trafficProvider = trafficProvider;\n        }\n\n        /// <summary>\n        /// Durakları en kısa sürede tamamlayacak şekilde sıralar\n        /// </summary>\n        /// <param name="waypoints">Sıralanacak durak listesi</param>\n        /// <param name="startPoint">Başlangıç noktası</param>\n        /// <param name="endPoint">Bitiş noktası (opsiyonel)</param>\n        /// <returns>Optimize edilmiş durak sırası</returns>\n        public async Task<List<LocationModel>> OptimizeRouteAsync(\n            List<LocationModel> waypoints,\n            LocationModel startPoint,\n            LocationModel? endPoint = null)\n        {\n            if (waypoints == null || waypoints.Count == 0)\n                return new List<LocationModel>();\n\n            if (waypoints.Count == 1)\n                return new List<LocationModel> { waypoints[0] };\n\n            try\n            {\n                // Tüm noktaları birleştir (başlangıç + duraklar + bitiş)\n                var allPoints = new List<LocationModel> { startPoint };\n                allPoints.AddRange(waypoints);\n                if (endPoint != null)\n                    allPoints.Add(endPoint);\n\n                // Mesafe matrisini hesapla\n                var distanceMatrix = await CalculateDistanceMatrixAsync(allPoints);\n\n                // TSP algoritması ile en kısa yolu bul\n                var optimizedOrder = SolveTSP(distanceMatrix);\n\n                // Optimize edilmiş sıraya göre durakları döndür\n                var result = new List<LocationModel>();\n                foreach (var index in optimizedOrder.Skip(1)) // Başlangıç noktasını atla\n                {\n                    if (index < allPoints.Count)\n                    {\n                        var point = allPoints[index];\n                        if (point != startPoint && (endPoint == null || point != endPoint))\n                        {\n                            result.Add(point);\n                        }\n                    }\n                }\n\n                return result;\n            }\n            catch (Exception ex)\n            {\n                System.Diagnostics.Debug.WriteLine($"Rota optimizasyonu hatası: {ex.Message}");\n                // Hata durumunda orijinal sıralamayı döndür\n                return waypoints;\n            }\n        }\n\n        /// <summary>\n        /// Tüm noktalar arası mesafe matrisini hesaplar\n        /// </summary>\n        private async Task<double[,]> CalculateDistanceMatrixAsync(List<LocationModel> points)\n        {\n            var matrix = new double[points.Count, points.Count];\n\n            for (int i = 0; i < points.Count; i++)\n            {\n                for (int j = 0; j < points.Count; j++)\n                {\n                    if (i == j)\n                    {\n                        matrix[i, j] = 0;\n                    }\n                    else\n                    {\n                        matrix[i, j] = await CalculateTravelTimeAsync(points[i], points[j]);\n                    }\n                }\n            }\n\n            return matrix;\n        }\n\n        /// <summary>\n        /// İki nokta arası seyahat süresini hesaplar (trafik verisi ile)\n        /// </summary>\n        private async Task<double> CalculateTravelTimeAsync(LocationModel from, LocationModel to)\n        {\n            try\n            {\n                // Trafik verisi varsa kullan\n                if (_trafficProvider != null)\n                {\n                    var trafficTime = await _trafficProvider.GetTravelTimeAsync(from, to);\n                    if (trafficTime.HasValue)\n                        return trafficTime.Value;\n                }\n\n                // Trafik verisi yoksa rota servisi ile hesapla\n                var route = await _routeService.GetRouteAsync(from, to);\n                if (route != null && route.Count >= 2)\n                {\n                    // Basit mesafe bazlı süre hesabı (ortalama hız 50 km/h)\n                    var distance = CalculateHaversineDistance(from, to);\n                    var speedKmh = 50.0; // Ortalama şehir içi hız\n                    return (distance / speedKmh) * 60; // Dakika cinsinden\n                }\n\n                // Fallback olarak Haversine mesafesi kullan\n                return CalculateHaversineDistance(from, to) / 50.0 * 60;\n            }\n            catch\n            {\n                // Hata durumunda Haversine mesafesi kullan\n                return CalculateHaversineDistance(from, to) / 50.0 * 60;\n            }\n        }\n\n        /// <summary>\n        /// Haversine formülü ile iki nokta arası mesafeyi hesaplar (km)\n        /// </summary>\n        private double CalculateHaversineDistance(LocationModel point1, LocationModel point2)\n        {\n            const double EarthRadiusKm = 6371.0;\n\n            var lat1Rad = point1.Latitude * Math.PI / 180.0;\n            var lon1Rad = point1.Longitude * Math.PI / 180.0;\n            var lat2Rad = point2.Latitude * Math.PI / 180.0;\n            var lon2Rad = point2.Longitude * Math.PI / 180.0;\n\n            var deltaLat = lat2Rad - lat1Rad;\n            var deltaLon = lon2Rad - lon1Rad;\n\n            var a = Math.Sin(deltaLat / 2) * Math.Sin(deltaLat / 2) +\n                    Math.Cos(lat1Rad) * Math.Cos(lat2Rad) *\n                    Math.Sin(deltaLon / 2) * Math.Sin(deltaLon / 2);\n\n            var c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));\n\n            return EarthRadiusKm * c;\n        }\n\n        /// <summary>\n        /// Traveling Salesman Problem için yaklaşık çözüm (Nearest Neighbor algoritması)\n        /// </summary>\n        private List<int> SolveTSP(double[,] distanceMatrix)\n        {\n            int n = distanceMatrix.GetLength(0);\n            var visited = new bool[n];\n            var path = new List<int>();\n\n            // Başlangıç noktasından başla (index 0)\n            int current = 0;\n            visited[current] = true;\n            path.Add(current);\n\n            // Tüm noktaları ziyaret et\n            for (int i = 1; i < n; i++)\n            {\n                int nearest = -1;\n                double minDistance = double.MaxValue;\n\n                // Ziyaret edilmemiş en yakın noktayı bul\n                for (int j = 0; j < n; j++)\n                {\n                    if (!visited[j] && distanceMatrix[current, j] < minDistance)\n                    {\n                        minDistance = distanceMatrix[current, j];\n                        nearest = j;\n                    }\n                }\n\n                if (nearest != -1)\n                {\n                    visited[nearest] = true;\n                    path.Add(nearest);\n                    current = nearest;\n                }\n            }\n\n            return path;\n        }\n\n        /// <summary>\n        /// Optimize edilmiş rotanın toplam süresini hesaplar\n        /// </summary>\n        public async Task<double> CalculateTotalRouteTimeAsync(\n            List<LocationModel> waypoints,\n            LocationModel startPoint,\n            LocationModel? endPoint = null)\n        {\n            var optimizedWaypoints = await OptimizeRouteAsync(waypoints, startPoint, endPoint);\n\n            var allPoints = new List<LocationModel> { startPoint };\n            allPoints.AddRange(optimizedWaypoints);\n            if (endPoint != null)\n                allPoints.Add(endPoint);\n\n            double totalTime = 0;\n            for (int i = 0; i < allPoints.Count - 1; i++)\n            {\n                totalTime += await CalculateTravelTimeAsync(allPoints[i], allPoints[i + 1]);\n            }\n\n            return totalTime;\n        }\n\n        /// <summary>\n        /// Optimize edilmiş rotanın toplam mesafesini hesaplar\n        /// </summary>\n        public async Task<double> CalculateTotalRouteDistanceAsync(\n            List<LocationModel> waypoints,\n            LocationModel startPoint,\n            LocationModel? endPoint = null)\n        {\n            var optimizedWaypoints = await OptimizeRouteAsync(waypoints, startPoint, endPoint);\n\n            var allPoints = new List<LocationModel> { startPoint };\n            allPoints.AddRange(optimizedWaypoints);\n            if (endPoint != null)\n                allPoints.Add(endPoint);\n\n            double totalDistance = 0;\n            for (int i = 0; i < allPoints.Count - 1; i++)\n            {\n                totalDistance += CalculateHaversineDistance(allPoints[i], allPoints[i + 1]);\n            }\n\n            return totalDistance;\n        }\n    }\n\n    /// <summary>\n    /// Trafik verisi sağlayıcısı interface'i\n    /// </summary>\n    public interface ITrafficDataProvider\n    {\n        /// <summary>\n        /// İki nokta arası seyahat süresini trafik verisi ile hesaplar\n        /// </summary>\n        Task<double?> GetTravelTimeAsync(LocationModel from, LocationModel to);\n\n        /// <summary>\n        /// Belirtilen bölgedeki trafik yoğunluğunu döndürür (0-1 arası)\n        /// </summary>\n        Task<double?> GetTrafficDensityAsync(double latitude, double longitude);\n\n        /// <summary>\n        /// Trafik verisinin güncellik durumunu kontrol eder\n        /// </summary>\n        Task<bool> IsTrafficDataFreshAsync();\n    }\n\n    /// <summary>\n    /// RouteService için rota optimizasyonu extension metodları\n    /// </summary>\n    public static class RouteServiceExtensions\n    {\n        /// <summary>\n        /// RouteService'e rota optimizasyonu özelliği ekler\n        /// </summary>\n        public static async Task<List<LocationModel>> GetOptimizedRouteAsync(\n            this IRouteService routeService,\n            List<LocationModel> waypoints,\n            LocationModel startPoint,\n            LocationModel? endPoint = null,\n            ITrafficDataProvider? trafficProvider = null,\n            bool useOptimization = true)\n        {\n            if (!useOptimization || waypoints == null || waypoints.Count <= 1)\n            {\n                // Optimizasyon kullanılmayacaksa veya tek durak varsa normal sıralamayı döndür\n                return waypoints ?? new List<LocationModel>();\n            }\n\n            var optimizer = new RouteOptimizer(routeService, trafficProvider);\n            return await optimizer.OptimizeRouteAsync(waypoints, startPoint, endPoint);\n        }\n\n        /// <summary>\n        /// Optimize edilmiş rotanın toplam süresini hesaplar\n        /// </summary>\n        public static async Task<double> CalculateOptimizedRouteTimeAsync(\n            this IRouteService routeService,\n            List<LocationModel> waypoints,\n            LocationModel startPoint,\n            LocationModel? endPoint = null,\n            ITrafficDataProvider? trafficProvider = null)\n        {\n            var optimizer = new RouteOptimizer(routeService, trafficProvider);\n            return await optimizer.CalculateTotalRouteTimeAsync(waypoints, startPoint, endPoint);\n        }\n\n        /// <summary>\n        /// Optimize edilmiş rotanın toplam mesafesini hesaplar\n        /// </summary>\n        public static async Task<double> CalculateOptimizedRouteDistanceAsync(\n            this IRouteService routeService,\n            List<LocationModel> waypoints,\n            LocationModel startPoint,\n            LocationModel? endPoint = null,\n            ITrafficDataProvider? trafficProvider = null)\n        {\n            var optimizer = new RouteOptimizer(routeService, trafficProvider);\n            return await optimizer.CalculateTotalRouteDistanceAsync(waypoints, startPoint, endPoint);\n        }\n    }\n}\n