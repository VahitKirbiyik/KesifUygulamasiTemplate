# Test-RouteDeviation.ps1\n# Route deviation simulation and fallback test script\n# Tests route deviation detection and recovery mechanisms\n\nparam(\n    [string]$ProjectPath = $PSScriptRoot,\n    [string]$TestEnvironment = "Development",\n    [switch]$EnableDeviationSimulation = $true,\n    [switch]$TestFallbackRouting = $true,\n    [switch]$EnableBadgeTrigger = $true,\n    [switch]$GenerateTestReport = $true,\n    [int]$DeviationScenarios = 5,\n    [double]$DeviationThresholdMeters = 50,\n    [int]$GpsUpdateIntervalMs = 1000,\n    [string]$StartLocation = "41.0082,28.9784",  # Istanbul coordinates\n    [string]$EndLocation = "41.0151,28.9795"     # Nearby location\n)\n\n# Environment variables for route deviation testing\n$env:ROUTE_DEVIATION_TEST_ENABLED = $EnableDeviationSimulation.ToString().ToLower()\n$env:DEVIATION_THRESHOLD_METERS = $DeviationThresholdMeters.ToString()\n$env:GPS_UPDATE_INTERVAL_MS = $GpsUpdateIntervalMs.ToString()\n$env:BADGE_TRIGGER_ENABLED = $EnableBadgeTrigger.ToString().ToLower()\n\n# Test configuration\n$testConfig = @{\n    ProjectPath = $ProjectPath\n    TestEnvironment = $TestEnvironment\n    StartTime = Get-Date\n    DeviationScenarios = $DeviationScenarios\n    DeviationsDetected = 0\n    FallbackRoutesCalculated = 0\n    RecoverySuccessCount = 0\n    TestResults = @()\n    BadgeTriggers = @()\n}\n\n# Create test output directories\n$testOutputPath = Join-Path $ProjectPath "test-results\route-deviation"\nNew-Item -ItemType Directory -Force -Path $testOutputPath | Out-Null\n\nWrite-Host "=== Route Deviation Test Started ===" -ForegroundColor Cyan\nWrite-Host "Project Path: $ProjectPath" -ForegroundColor Gray\nWrite-Host "Test Environment: $TestEnvironment" -ForegroundColor Gray\nWrite-Host "Deviation Scenarios: $DeviationScenarios" -ForegroundColor Gray\nWrite-Host "Deviation Threshold: ${DeviationThresholdMeters}m" -ForegroundColor Gray\nWrite-Host ""\n\n# Test classes\nclass GpsLocation {\n    [double]$Latitude\n    [double]$Longitude\n    [DateTime]$Timestamp\n    [double]$Accuracy\n    [string]$Source\n\n    GpsLocation([double]$lat, [double]$lon) {\n        $this.Latitude = $lat\n        $this.Longitude = $lon\n        $this.Timestamp = Get-Date\n        $this.Accuracy = 5.0  # Default accuracy in meters\n        $this.Source = "GPS"\n    }\n\n    [double]DistanceTo([GpsLocation]$other) {\n        # Haversine formula for distance calculation\n        $lat1 = $this.Latitude * [Math]::PI / 180\n        $lon1 = $this.Longitude * [Math]::PI / 180\n        $lat2 = $other.Latitude * [Math]::PI / 180\n        $lon2 = $other.Longitude * [Math]::PI / 180\n\n        $dLat = $lat2 - $lat1\n        $dLon = $lon2 - $lon1\n\n        $a = [Math]::Sin($dLat / 2) * [Math]::Sin($dLat / 2) +\n             [Math]::Cos($lat1) * [Math]::Cos($lat2) *\n             [Math]::Sin($dLon / 2) * [Math]::Sin($dLon / 2)\n\n        $c = 2 * [Math]::Atan2([Math]::Sqrt($a), [Math]::Sqrt(1 - $a))\n\n        return 6371000 * $c  # Earth radius in meters\n    }\n}\n\nclass RouteSegment {\n    [GpsLocation]$StartPoint\n    [GpsLocation]$EndPoint\n    [double]$Distance\n    [string]$Instructions\n    [int]$DurationSeconds\n\n    RouteSegment([GpsLocation]$start, [GpsLocation]$end) {\n        $this.StartPoint = $start\n        $this.EndPoint = $end\n        $this.Distance = $start.DistanceTo($end)\n        $this.Instructions = "Navigate from ($($start.Latitude), $($start.Longitude)) to ($($end.Latitude), $($end.Longitude))"\n        $this.DurationSeconds = [Math]::Ceiling($this.Distance / 13.89)  # Assuming 50 km/h average speed\n    }\n}\n\nclass DeviationResult {\n    [int]$ScenarioId\n    [GpsLocation]$OriginalLocation\n    [GpsLocation]$DeviatedLocation\n    [double]$DeviationDistance\n    [bool]$DeviationDetected\n    [RouteSegment]$FallbackRoute\n    [bool]$RecoverySuccessful\n    [DateTime]$DetectionTime\n    [DateTime]$RecoveryTime\n    [string]$DeviationType\n    [string]$ErrorMessage\n\n    DeviationResult([int]$scenarioId) {\n        $this.ScenarioId = $scenarioId\n        $this.DeviationDetected = $false\n        $this.RecoverySuccessful = $false\n        $this.DetectionTime = Get-Date\n    }\n}\n\nclass MockDeviationHandler {\n    [double]$DeviationThreshold\n    [System.Collections.Generic.List[RouteSegment]]$OriginalRoute\n    [System.Collections.Generic.List[DeviationResult]]$Deviations\n\n    MockDeviationHandler([double]$threshold) {\n        $this.DeviationThreshold = $threshold\n        $this.OriginalRoute = New-Object System.Collections.Generic.List[RouteSegment]\n        $this.Deviations = New-Object System.Collections.Generic.List[DeviationResult]\n    }\n\n    [void]SetOriginalRoute([System.Collections.Generic.List[RouteSegment]]$route) {\n        $this.OriginalRoute = $route\n    }\n\n    [DeviationResult]DetectDeviation([GpsLocation]$currentLocation, [int]$scenarioId) {\n        $result = [DeviationResult]::new($scenarioId)\n        $result.OriginalLocation = $this.GetClosestRoutePoint($currentLocation)\n        $result.DeviatedLocation = $currentLocation\n        $result.DeviationDistance = $result.OriginalLocation.DistanceTo($currentLocation)\n\n        if ($result.DeviationDistance -gt $this.DeviationThreshold) {\n            $result.DeviationDetected = $true\n            $result.DetectionTime = Get-Date\n            $result.DeviationType = $this.ClassifyDeviation($result.DeviationDistance)\n\n            # Calculate fallback route\n            $result.FallbackRoute = $this.CalculateFallbackRoute($result.OriginalLocation, $currentLocation)\n            $testConfig.FallbackRoutesCalculated++\n\n            # Simulate recovery\n            $recoverySuccess = (Get-Random -Maximum 100) -lt 85  # 85% success rate\n            if ($recoverySuccess) {\n                $result.RecoverySuccessful = $true\n                $result.RecoveryTime = Get-Date\n                $testConfig.RecoverySuccessCount++\n            } else {\n                $result.ErrorMessage = "Fallback route calculation failed"\n            }\n        }\n\n        $this.Deviations.Add($result)\n        return $result\n    }\n\n    [GpsLocation]GetClosestRoutePoint([GpsLocation]$location) {\n        $closestPoint = $null\n        $minDistance = [double]::MaxValue\n\n        foreach ($segment in $this.OriginalRoute) {\n            $distanceToStart = $location.DistanceTo($segment.StartPoint)\n            $distanceToEnd = $location.DistanceTo($segment.EndPoint)\n\n            if ($distanceToStart -lt $minDistance) {\n                $minDistance = $distanceToStart\n                $closestPoint = $segment.StartPoint\n            }\n\n            if ($distanceToEnd -lt $minDistance) {\n                $minDistance = $distanceToEnd\n                $closestPoint = $segment.EndPoint\n            }\n        }\n\n        return $closestPoint\n    }\n\n    [string]ClassifyDeviation([double]$distance) {\n        if ($distance -lt 100) { return "Minor" }\n        elseif ($distance -lt 500) { return "Moderate" }\n        elseif ($distance -lt 1000) { return "Major" }\n        else { return "Critical" }\n    }\n\n    [RouteSegment]CalculateFallbackRoute([GpsLocation]$from, [GpsLocation]$to) {\n        # Simulate route calculation with some randomness\n        $midLat = ($from.Latitude + $to.Latitude) / 2 + (Get-Random -Minimum -0.001 -Maximum 0.001)\n        $midLon = ($from.Longitude + $to.Longitude) / 2 + (Get-Random -Minimum -0.001 -Maximum 0.001)\n\n        $midPoint = [GpsLocation]::new($midLat, $midLon)\n        return [RouteSegment]::new($from, $midPoint)\n    }\n}\n\n# Initialize mock deviation handler\n$mockHandler = [MockDeviationHandler]::new($DeviationThresholdMeters)\n\n# Helper functions\nfunction New-MockRoute {\n    param([string]$startCoords, [string]$endCoords, [int]$segments = 5)\n\n    $route = New-Object System.Collections.Generic.List[RouteSegment]\n\n    $startParts = $startCoords -split ','\n    $endParts = $endCoords -split ','\n\n    $startLat = [double]$startParts[0]\n    $startLon = [double]$startParts[1]\n    $endLat = [double]$endParts[0]\n    $endLon = [double]$endParts[1]\n\n    $latStep = ($endLat - $startLat) / $segments\n    $lonStep = ($endLon - $startLon) / $segments\n\n    for ($i = 0; $i -lt $segments; $i++) {\n        $segmentStart = [GpsLocation]::new($startLat + ($latStep * $i), $startLon + ($lonStep * $i))\n        $segmentEnd = [GpsLocation]::new($startLat + ($latStep * ($i + 1)), $startLon + ($lonStep * ($i + 1)))\n\n        $route.Add([RouteSegment]::new($segmentStart, $segmentEnd))\n    }\n\n    return $route\n}\n\nfunction New-DeviatedLocation {\n    param([GpsLocation]$originalLocation, [double]$deviationDistance, [double]$angle)\n\n    # Calculate new position using deviation distance and angle\n    $angleRad = $angle * [Math]::PI / 180\n    $latOffset = ($deviationDistance / 111320) * [Math]::Cos($angleRad)  # Rough conversion to degrees\n    $lonOffset = ($deviationDistance / 111320) * [Math]::Sin($angleRad) / [Math]::Cos($originalLocation.Latitude * [Math]::PI / 180)\n\n    return [GpsLocation]::new($originalLocation.Latitude + $latOffset, $originalLocation.Longitude + $lonOffset)\n}\n\n# Test functions\nfunction Test-DeviationDetection {\n    Write-Host "Testing Route Deviation Detection..." -ForegroundColor Yellow\n\n    # Create mock route\n    $originalRoute = New-MockRoute $StartLocation $EndLocation 5\n    $mockHandler.SetOriginalRoute($originalRoute)\n\n    $deviationResults = @()\n\n    for ($i = 1; $i -le $DeviationScenarios; $i++) {\n        Write-Host "  Running deviation scenario $i..." -ForegroundColor Gray\n\n        # Select random point on route\n        $routePoint = $originalRoute[(Get-Random -Minimum 0 -Maximum $originalRoute.Count)].StartPoint\n\n        # Create deviated location\n        $deviationDistance = $DeviationThresholdMeters + (Get-Random -Minimum 10 -Maximum 200)\n        $deviationAngle = Get-Random -Minimum 0 -Maximum 360\n        $deviatedLocation = New-DeviatedLocation $routePoint $deviationDistance $deviationAngle\n\n        # Detect deviation\n        $result = $mockHandler.DetectDeviation($deviatedLocation, $i)\n        $deviationResults += $result\n\n        if ($result.DeviationDetected) {\n            $testConfig.DeviationsDetected++\n            Write-Host "    ✓ Deviation detected: $($result.DeviationDistance.ToString("F1"))m ($($result.DeviationType))" -ForegroundColor Green\n\n            if ($result.RecoverySuccessful) {\n                Write-Host "    ✓ Recovery successful" -ForegroundColor Green\n            } else {\n                Write-Host "    ✗ Recovery failed: $($result.ErrorMessage)" -ForegroundColor Red\n            }\n        } else {\n            Write-Host "    - No deviation detected" -ForegroundColor Gray\n        }\n\n        # Simulate GPS update delay\n        Start-Sleep -Milliseconds $GpsUpdateIntervalMs\n    }\n\n    return $deviationResults\n}\n\nfunction Test-FallbackRouting {\n    Write-Host "Testing Fallback Route Calculation..." -ForegroundColor Yellow\n\n    $fallbackResults = @()\n\n    foreach ($deviation in $mockHandler.Deviations) {\n        if ($deviation.DeviationDetected -and $deviation.FallbackRoute) {\n            $result = @{\n                ScenarioId = $deviation.ScenarioId\n                OriginalDistance = $deviation.DeviationDistance\n                FallbackDistance = $deviation.FallbackRoute.Distance\n                RecoveryTime = if ($deviation.RecoverySuccessful) {\n                    ($deviation.RecoveryTime - $deviation.DetectionTime).TotalMilliseconds\n                } else { 0 }\n                Successful = $deviation.RecoverySuccessful\n            }\n\n            $fallbackResults += $result\n\n            Write-Host "  Scenario $($deviation.ScenarioId): Fallback route calculated ($($result.FallbackDistance.ToString("F1"))m)" -ForegroundColor Cyan\n        }\n    }\n\n    return $fallbackResults\n}\n\nfunction Test-BadgeTriggers {\n    Write-Host "Testing Badge Triggers..." -ForegroundColor Yellow\n\n    $badgeResults = @()\n\n    # Test Route-Stabilized badge (requires 5 deviation recoveries)\n    if ($testConfig.RecoverySuccessCount -ge 5) {\n        $badge = @{\n            BadgeName = "Route-Stabilized"\n            TriggerReason = "5 successful route deviation recoveries"\n            TriggerTime = Get-Date\n            Triggered = $true\n            Details = "Successfully recovered from $testConfig.RecoverySuccessCount route deviations"\n        }\n        $badgeResults += $badge\n        Write-Host "✓ Route-Stabilized badge triggered!" -ForegroundColor Green\n    }\n\n    return $badgeResults\n}\n\nfunction Test-PerformanceMetrics {\n    Write-Host "Testing Performance Metrics..." -ForegroundColor Yellow\n\n    $metrics = @{\n        TotalScenarios = $DeviationScenarios\n        DeviationsDetected = $testConfig.DeviationsDetected\n        DetectionRate = [math]::Round(($testConfig.DeviationsDetected / $DeviationScenarios) * 100, 2)\n        FallbackRoutesCalculated = $testConfig.FallbackRoutesCalculated\n        RecoverySuccessCount = $testConfig.RecoverySuccessCount\n        RecoveryRate = if ($testConfig.DeviationsDetected -gt 0) {\n            [math]::Round(($testConfig.RecoverySuccessCount / $testConfig.DeviationsDetected) * 100, 2)\n        } else { 0 }\n        AverageDetectionTime = 0\n        AverageRecoveryTime = 0\n    }\n\n    # Calculate average times\n    $detectionTimes = @()\n    $recoveryTimes = @()\n\n    foreach ($deviation in $mockHandler.Deviations) {\n        if ($deviation.DeviationDetected) {\n            $detectionTimes += ($deviation.DetectionTime - $deviation.DeviatedLocation.Timestamp).TotalMilliseconds\n\n            if ($deviation.RecoverySuccessful) {\n                $recoveryTimes += ($deviation.RecoveryTime - $deviation.DetectionTime).TotalMilliseconds\n            }\n        }\n    }\n\n    if ($detectionTimes.Count -gt 0) {\n        $metrics.AverageDetectionTime = [math]::Round(($detectionTimes | Measure-Object -Average).Average, 2)\n    }\n\n    if ($recoveryTimes.Count -gt 0) {\n        $metrics.AverageRecoveryTime = [math]::Round(($recoveryTimes | Measure-Object -Average).Average, 2)\n    }\n\n    Write-Host "Performance Metrics:" -ForegroundColor Cyan\n    Write-Host "  Detection Rate: $($metrics.DetectionRate)%" -ForegroundColor Yellow\n    Write-Host "  Recovery Rate: $($metrics.RecoveryRate)%" -ForegroundColor Yellow\n    Write-Host "  Avg Detection Time: $($metrics.AverageDetectionTime)ms" -ForegroundColor Yellow\n    Write-Host "  Avg Recovery Time: $($metrics.AverageRecoveryTime)ms" -ForegroundColor Yellow\n\n    return $metrics\n}\n\n# Run tests\n$testResults = @{}\n\nif ($EnableDeviationSimulation) {\n    $testResults.DeviationResults = Test-DeviationDetection\n}\n\nif ($TestFallbackRouting) {\n    $testResults.FallbackResults = Test-FallbackRouting\n}\n\n$testResults.PerformanceMetrics = Test-PerformanceMetrics\n\nif ($EnableBadgeTrigger) {\n    $testResults.BadgeResults = Test-BadgeTriggers\n}\n\n# Generate test report\nif ($GenerateTestReport) {\n    Write-Host ""\n    Write-Host "=== Generating Test Report ===" -ForegroundColor Cyan\n\n    $reportData = @{\n        TestRun = @{\n            StartTime = $testConfig.StartTime\n            EndTime = Get-Date\n            Duration = ((Get-Date) - $testConfig.StartTime).TotalSeconds\n            Environment = $TestEnvironment\n            Configuration = @{\n                DeviationScenarios = $DeviationScenarios\n                DeviationThresholdMeters = $DeviationThresholdMeters\n                GpsUpdateIntervalMs = $GpsUpdateIntervalMs\n                StartLocation = $StartLocation\n                EndLocation = $EndLocation\n                EnableDeviationSimulation = $EnableDeviationSimulation\n                TestFallbackRouting = $TestFallbackRouting\n                EnableBadgeTrigger = $EnableBadgeTrigger\n            }\n        }\n        Results = @{\n            TotalScenarios = $DeviationScenarios\n            DeviationsDetected = $testConfig.DeviationsDetected\n            DetectionRate = [math]::Round(($testConfig.DeviationsDetected / $DeviationScenarios) * 100, 2)\n            FallbackRoutesCalculated = $testConfig.FallbackRoutesCalculated\n            RecoverySuccessCount = $testConfig.RecoverySuccessCount\n            RecoveryRate = if ($testConfig.DeviationsDetected -gt 0) {\n                [math]::Round(($testConfig.RecoverySuccessCount / $testConfig.DeviationsDetected) * 100, 2)\n            } else { 0 }\n            BadgeTriggers = $testResults.BadgeResults | ForEach-Object {\n                @{\n                    BadgeName = $_.BadgeName\n                    Triggered = $_.Triggered\n                    Reason = $_.TriggerReason\n                    Details = $_.Details\n                }\n            }\n        }\n        DetailedResults = @{\n            DeviationScenarios = $testResults.DeviationResults | ForEach-Object {\n                @{\n                    ScenarioId = $_.ScenarioId\n                    DeviationDetected = $_.DeviationDetected\n                    DeviationDistance = $_.DeviationDistance\n                    DeviationType = $_.DeviationType\n                    RecoverySuccessful = $_.RecoverySuccessful\n                    DetectionTime = $_.DetectionTime\n                    RecoveryTime = $_.RecoveryTime\n                    ErrorMessage = $_.ErrorMessage\n                    FallbackRouteDistance = if ($_.FallbackRoute) { $_.FallbackRoute.Distance } else { 0 }\n                }\n            }\n            PerformanceMetrics = $testResults.PerformanceMetrics\n        }\n    }\n\n    $reportPath = Join-Path $testOutputPath "route-deviation-test-report.json"\n    $reportData | ConvertTo-Json -Depth 10 | Out-File -FilePath $reportPath -Encoding UTF8\n\n    Write-Host "Test report generated: $reportPath" -ForegroundColor Green\n}\n\n# Summary\nWrite-Host ""\nWrite-Host "=== Route Deviation Test Summary ===" -ForegroundColor Cyan\nWrite-Host "Total Scenarios: $($DeviationScenarios)" -ForegroundColor White\nWrite-Host "Deviations Detected: $($testConfig.DeviationsDetected)" -ForegroundColor Yellow\nWrite-Host "Detection Rate: $([math]::Round(($testConfig.DeviationsDetected / $DeviationScenarios) * 100, 2))%" -ForegroundColor Yellow\nWrite-Host "Recovery Success: $($testConfig.RecoverySuccessCount)" -ForegroundColor Green\nWrite-Host "Recovery Rate: $(if ($testConfig.DeviationsDetected -gt 0) { [math]::Round(($testConfig.RecoverySuccessCount / $testConfig.DeviationsDetected) * 100, 2) } else { 0 })%" -ForegroundColor Green\n\nif ($testResults.BadgeResults) {\n    Write-Host "Badge Triggers: $($testResults.BadgeResults.Count)" -ForegroundColor Magenta\n    foreach ($badge in $testResults.BadgeResults) {\n        if ($badge.Triggered) {\n            Write-Host "  ✓ $($badge.BadgeName): $($badge.Details)" -ForegroundColor Green\n        }\n    }\n}\n\nWrite-Host ""\nWrite-Host "=== Route Deviation Test Completed ===" -ForegroundColor Cyan\n\n# Return test results for CI/CD integration\nreturn @{\n    Success = $testConfig.RecoverySuccessCount -ge ($DeviationScenarios * 0.7)  # 70% recovery success required\n    TotalScenarios = $DeviationScenarios\n    DeviationsDetected = $testConfig.DeviationsDetected\n    DetectionRate = [math]::Round(($testConfig.DeviationsDetected / $DeviationScenarios) * 100, 2)\n    RecoverySuccessCount = $testConfig.RecoverySuccessCount\n    RecoveryRate = if ($testConfig.DeviationsDetected -gt 0) {\n        [math]::Round(($testConfig.RecoverySuccessCount / $testConfig.DeviationsDetected) * 100, 2)\n    } else { 0 }\n    BadgeTriggers = $testResults.BadgeResults.Count\n    TestDuration = ((Get-Date) - $testConfig.StartTime).TotalSeconds\n}\n